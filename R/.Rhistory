Dim <- 2
multip.kernel <- function(u){
# u is a vector in 2-dim
(1-u[1])*(1-u[2])*9/16
}
sphi.kernel <- function(u){
# u is a vector in 2-dim
(1-t(u)%*%u)*2/pi
}
kde.multiple <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=100)
y <- seq(40, 100, length.out=100)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
H <- diag(c(1,1))
# # single core code
# for(ii in 1:length(x)){
#   for (jj in 1:length(y)) {
#     u <- c(x[ii], y[jj])
#     f.hat.multiple[ii, jj] <- kde.multiple(u, H)
#     f.hat.sphi[ii, jj] <- kde.sphi(u, H)
#   }
# }
# 2 cores code
ex <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- matrix(c(xx, y[jj]), nrow=1)
return(kde.multiple(u, H))
}, x[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
res <- parSapply(cl, 1:length(x), ex)
ii=1
unlist(lapply(1:length(y), function(jj, xx) {
u <- matrix(c(xx, y[jj]), nrow=1)
return(kde.multiple(u, H))
}, x[ii]))
data("faithful")
dat <- data.matrix(faithful)
n <- dim(dat)[1]
Dim <- 2
multip.kernel <- function(u){
# u is a vector in 2-dim
(1-u[1])*(1-u[2])*9/16
}
sphi.kernel <- function(u){
# u is a vector in 2-dim
(1-t(u)%*%u)*2/pi
}
kde.multiple <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=100)
y <- seq(40, 100, length.out=100)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
H <- diag(c(1,1))
# # single core code
# for(ii in 1:length(x)){
#   for (jj in 1:length(y)) {
#     u <- c(x[ii], y[jj])
#     f.hat.multiple[ii, jj] <- kde.multiple(u, H)
#     f.hat.sphi[ii, jj] <- kde.sphi(u, H)
#   }
# }
# 2 cores code
ex <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj]))
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
data("faithful")
dat <- data.matrix(faithful)
n <- dim(dat)[1]
Dim <- 2
multip.kernel <- function(u){
# u is a vector in 2-dim
(1-u[1])*(1-u[2])*9/16
}
sphi.kernel <- function(u){
# u is a vector in 2-dim
(1-t(u)%*%u)*2/pi
}
kde.multiple <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=100)
y <- seq(40, 100, length.out=100)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
H <- diag(c(1,1))
# # single core code
# for(ii in 1:length(x)){
#   for (jj in 1:length(y)) {
#     u <- c(x[ii], y[jj])
#     f.hat.multiple[ii, jj] <- kde.multiple(u, H)
#     f.hat.sphi[ii, jj] <- kde.sphi(u, H)
#   }
# }
# 2 cores code
ex <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
res <- parSapply(cl, 1:length(x), ex)
stopCluster(cl)
plot_ly() %>%
add_surface(z = ~res)
# plot_ly() %>%
# add_surface(z = ~f.hat.sphi)
data("faithful")
dat <- data.matrix(faithful)
n <- dim(dat)[1]
Dim <- 2
multip.kernel <- function(u){
# u is a vector in 2-dim
(1-u[1])*(1-u[2])*9/16
}
sphi.kernel <- function(u){
# u is a vector in 2-dim
(1-t(u)%*%u)*2/pi
}
kde.multiple <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=100)
y <- seq(40, 100, length.out=100)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
H <- diag(c(1,1))
# # single core code
# for(ii in 1:length(x)){
#   for (jj in 1:length(y)) {
#     u <- c(x[ii], y[jj])
#     f.hat.multiple[ii, jj] <- kde.multiple(u, H)
#     f.hat.sphi[ii, jj] <- kde.sphi(u, H)
#   }
# }
# 2 cores code
ex.multiple <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
ex.sphi <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
f.hat.multiple <- parSapply(cl, 1:length(x), ex.multiple)
stopCluster(cl)
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
f.hat.sphi <- parSapply(cl, 1:length(x), ex.sphi)
stopCluster(cl)
plot_ly() %>%
add_surface(z = ~f.hat.multiple)
plot_ly() %>%
add_surface(z = ~f.hat.sphi)
ff <- function(xx, yy){
sin(xx+yy)
}
zz <- outer(xx, yy. ff)
ff <- function(xx, yy){
sin(xx+yy)
}
zz <- outer(xx, yy, ff)
ff <- function(xx, yy){
sin(xx+yy)
}
zz <- outer(x, y, ff)
plot_ly() %>% add_surface(z = ~zz)
Sig <- cov(dat)
diag(Sig)
Sigdiag(Sig)
Sig
diag(diag(Sig))
Sig^(1/2)
Sig <- cov(dat)
H.plug_in <- diag(diag(Sig)) * n^(-1/6) * (4 / 6)^(1/6)
H.scott <- diag(diag(Sig)) * n^(-1/6)
H.g_scott <- n^(-1/6) * Sig^(1/2)
c(H.plug_in, H.scott, H.g_scott)
data("faithful")
dat <- data.matrix(faithful)
n <- dim(dat)[1]
Dim <- 2
multip.kernel <- function(u){
# u is a vector in 2-dim
(1-u[1])*(1-u[2])*9/16
}
sphi.kernel <- function(u){
# u is a vector in 2-dim
(1-t(u)%*%u)*2/pi
}
kde.multiple <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=30)
y <- seq(40, 100, length.out=30)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
# bandwith selection
Sig <- cov(dat)
H.plug_in <- diag(diag(Sig)) * n^(-1/6) * (4 / 6)^(1/6)
H.scott <- diag(diag(Sig)) * n^(-1/6)
H.g_scott <- n^(-1/6) * Sig^(1/2)
estimate <- function(H){
# # single core code
# for(ii in 1:length(x)){
#   for (jj in 1:length(y)) {
#     u <- c(x[ii], y[jj])
#     f.hat.multiple[ii, jj] <- kde.multiple(u, H)
#     f.hat.sphi[ii, jj] <- kde.sphi(u, H)
#   }
# }
# more cores code
ex.multiple <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
ex.sphi <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
f.hat.multiple <- parSapply(cl, 1:length(x), ex.multiple)
stopCluster(cl)
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
f.hat.sphi <- parSapply(cl, 1:length(x), ex.sphi)
stopCluster(cl)
plot_ly() %>% add_surface(z = ~f.hat.multiple)
plot_ly() %>% add_surface(z = ~f.hat.sphi)
}
estimate(H.plug_in)
H.plug_in
data("faithful")
dat <- data.matrix(faithful)
n <- dim(dat)[1]
Dim <- 2
multip.kernel <- function(u){
# u is a vector in 2-dim
(1-u[1])*(1-u[2])*9/16
}
sphi.kernel <- function(u){
# u is a vector in 2-dim
(1-t(u)%*%u)*2/pi
}
kde.multiple <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=30)
y <- seq(40, 100, length.out=30)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
# bandwith selection
Sig <- cov(dat)
H.plug_in <- diag(diag(Sig)) * n^(-1/6) * (4 / 6)^(1/6)
H.scott <- diag(diag(Sig)) * n^(-1/6)
H.g_scott <- n^(-1/6) * Sig^(1/2)
estimate <- function(H){
# # single core code
# for(ii in 1:length(x)){
#   for (jj in 1:length(y)) {
#     u <- c(x[ii], y[jj])
#     f.hat.multiple[ii, jj] <- kde.multiple(u, H)
#     f.hat.sphi[ii, jj] <- kde.sphi(u, H)
#   }
# }
# more cores code
ex.multiple <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
ex.sphi <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H.plug_in', 'H.scott', 'H.g_scott', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
f.hat.multiple <- parSapply(cl, 1:length(x), ex.multiple)
stopCluster(cl)
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H.plug_in', 'H.scott', 'H.g_scott', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
f.hat.sphi <- parSapply(cl, 1:length(x), ex.sphi)
stopCluster(cl)
plot_ly() %>% add_surface(z = ~f.hat.multiple)
plot_ly() %>% add_surface(z = ~f.hat.sphi)
}
estimate(H.plug_in)
estimate(H.scott)
estimate(H.g_scott)
data("faithful")
dat <- data.matrix(faithful)
n <- dim(dat)[1]
Dim <- 2
multip.kernel <- function(u){
# u is a vector in 2-dim
(1-u[1])*(1-u[2])*9/16
}
sphi.kernel <- function(u){
# u is a vector in 2-dim
(1-t(u)%*%u)*2/pi
}
kde.multiple <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=30)
y <- seq(40, 100, length.out=30)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
# bandwith selection
Sig <- cov(dat)
H.plug_in <- diag(diag(Sig)) * n^(-1/6) * (4 / 6)^(1/6)
H.scott <- diag(diag(Sig)) * n^(-1/6)
H.g_scott <- n^(-1/6) * Sig^(1/2)
estimate <- function(H){
# single core code
for(ii in 1:length(x)){
for (jj in 1:length(y)) {
u <- c(x[ii], y[jj])
f.hat.multiple[ii, jj] <- kde.multiple(u, H)
f.hat.sphi[ii, jj] <- kde.sphi(u, H)
}
}
# # more cores code
# ex.multiple <- function(ii){
#   # ii: different index of x
#   # jj: index of y
#   unlist(lapply(1:length(y), function(jj, xx) {
#                                       u <- c(xx, y[jj])
#                                       return(kde.multiple(u, H))
#                             }, x[ii]))
# }
# ex.sphi <- function(ii){
#   # ii: different index of x
#   # jj: index of y
#   unlist(lapply(1:length(y), function(jj, xx) {
#                                       u <- c(xx, y[jj])
#                                       return(kde.multiple(u, H))
#                             }, x[ii]))
# }
# cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
# clusterExport(cl, c('dat' ,'x' , 'y', 'H.plug_in', 'H.scott', 'H.g_scott', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
# f.hat.multiple <- parSapply(cl, 1:length(x), ex.multiple)
# stopCluster(cl)
#
# cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
# clusterExport(cl, c('dat' ,'x' , 'y', 'H.plug_in', 'H.scott', 'H.g_scott', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
# f.hat.sphi <- parSapply(cl, 1:length(x), ex.sphi)
# stopCluster(cl)
plot_ly() %>% add_surface(z = ~f.hat.multiple)
plot_ly() %>% add_surface(z = ~f.hat.sphi)
}
estimate(H.plug_in)
estimate(H.scott)
estimate(H.g_scott)
H.g_scott
H.scott
H.plug_in
n^(-1/6)
H.g_scott
H.scott
H.plug_in
Sig
Sig^(1/2)
