res <- parSapply(cl, 1:10, ex)
k=10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, y[ii]))
}
ex(1)
library("FNN")
library("parallel")
k=10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, y[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn'))                # include all the function needed
res <- parSapply(cl, 1:10, ex)
library("FNN")
library("parallel")
k=10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, y[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn'))                # include all the function needed
res <- parSapply(cl, 1:10, ex)
library("FNN")
library("parallel")
k=10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn'))                # include all the function needed
res <- parSapply(cl, 1:10, ex)
library("FNN")
library("parallel")
k=10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz'))                # include all the function needed
res <- parSapply(cl, 1:10, ex)
library("FNN")
library("parallel")
k=10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'kdist'))                # include all the function needed
res <- parSapply(cl, 1:10, ex)
library("FNN")
library("parallel")
k=10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'kdist', 'k'))                # include all the function needed
res <- parSapply(cl, 1:10, ex)
# for (ii in 1:length(yy)) {
#   f.hat[ii,] <- unlist(lapply(1:length(zz), function(jj, y) {
#                                                     tt <- matrix(c(y, zz[jj]), nrow=1)
#                                                     return(f.knn(tt))
#                                             }, y[ii]))
#   # for (jj in 1:length(zz)) {
#   #   f.hat[ii,jj] <- f.knn(matrix(c(yy[ii], zz[jj]), nrow=1))
#   # }
# }
#
# # draw density  fucntion
# library("plotly")
#
# plot_ly() %>%
# add_surface(z = ~f.hat)
stopCluster(cl)
View(res)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library("FNN")
library("parallel")
k=10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'kdist', 'k'))                # include all the function needed
res <- parSapply(cl, 1:length(yy), ex)
stopCluster(cl)
# for (ii in 1:length(yy)) {
#   f.hat[ii,] <- unlist(lapply(1:length(zz), function(jj, y) {
#                                                     tt <- matrix(c(y, zz[jj]), nrow=1)
#                                                     return(f.knn(tt))
#                                             }, y[ii]))
#   # for (jj in 1:length(zz)) {
#   #   f.hat[ii,jj] <- f.knn(matrix(c(yy[ii], zz[jj]), nrow=1))
#   # }
# }
#
# draw density  fucntion
library("plotly")
plot_ly() %>%
add_surface(z = ~res)
View(kdist)
library("FNN")
library("parallel")
k <- 10
kdist <- knn.dist(x, k=k)
f.knn <- function(t){
# t <- matrix(c(y,z), nrow=1)
fhx <- 0
for (ii in 1:dim(x)[1]) {
h <- kdist[ii, k]
if (norm(x[ii,] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.1)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'kdist', 'k'))                # include all the function needed
res <- parSapply(cl, 1:length(yy), ex)
stopCluster(cl)
# for (ii in 1:length(yy)) {
#   f.hat[ii,] <- unlist(lapply(1:length(zz), function(jj, y) {
#                                                     tt <- matrix(c(y, zz[jj]), nrow=1)
#                                                     return(f.knn(tt))
#                                             }, y[ii]))
#   # for (jj in 1:length(zz)) {
#   #   f.hat[ii,jj] <- f.knn(matrix(c(yy[ii], zz[jj]), nrow=1))
#   # }
# }
#
# draw density  fucntion
library("plotly")
plot_ly() %>%
add_surface(z = ~res)
library("scatterplot3d")
install.packages("scatterplot3d")
library("scatterplot3d")
plot_ly() %>%
add_surface(z = ~res)
knnx.dist(data=x, query=matrix(c(1,2),1,2))
knnx.dist(data=x, query=matrix(c(1,2),1,2))[1,10]
knnx.index(data=x, query=matrix(c(1,2),1,2))
library("FNN")
library("parallel")
k <- 10
# kdist <- knn.dist(x, k=k)
f.knn <- function(t){
h <- knnx.dist(data=x, query=t, k=k)[1,10]
idx_t <- knnx.index(data=x, query=t, k=k)
fhx <- 0
for (ii in 1:dim(idx_t)[2]) {
if (norm(x[idx_t[ii],] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.5)
zz <- seq(40, 100, 1)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'kdist', 'k'))                # include all the function needed
res <- parSapply(cl, 1:length(yy), ex)
library("FNN")
library("parallel")
k <- 10
# kdist <- knn.dist(x, k=k)
f.knn <- function(t){
h <- knnx.dist(data=x, query=t, k=k)[1,10]
idx_t <- knnx.index(data=x, query=t, k=k)
fhx <- 0
for (ii in 1:dim(idx_t)[2]) {
if (norm(x[idx_t[ii],] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.5)
zz <- seq(40, 100, 1)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'kdist', 'k', 'knnx.dist', 'knnx.index'))                # include all the function needed
res <- parSapply(cl, 1:length(yy), ex)
stopCluster(cl)
# draw density  fucntion
library("plotly")
plot_ly() %>%
add_surface(z = ~res)
library("FNN")
library("parallel")
k <- 10
# kdist <- knn.dist(x, k=k)
f.knn <- function(t){
h <- knnx.dist(data=x, query=t, k=k)[1,10]
idx_t <- knnx.index(data=x, query=t, k=k)
fhx <- 0
for (ii in 1:dim(idx_t)[2]) {
if (norm(x[idx_t[ii],] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.05)
zz <- seq(40, 100, 0.1)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'k', 'knnx.dist', 'knnx.index'))                # include all the function needed
res <- parSapply(cl, 1:length(yy), ex)
stopCluster(cl)
# draw density  fucntion
library("plotly")
plot_ly() %>%
add_surface(z = ~res)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
data("faithful")
ggplot(faithful, aes(x = eruptions, y = waiting)) + geom_point() + stat_density2d()
# load data
library("mvtnorm") # multi-normal
data("faithful")
head(faithful, 5)
x <- data.matrix(faithful)
# initialization
set.seed(111)
n <- 272
K <- 2
Dim <- 2
eps <- 1e-4
Pi <- c(0.5, 0.5)
mu <- rep(0, Dim*K); dim(mu) <- c(Dim, K)
Sig <- rep(0, Dim*Dim*K); dim(Sig) <- c(Dim, Dim, K)
mu_tmp <- matrix(c(2,55, 4.5, 80), 2, 2)
for (k in 1:K) {
Sig[,,k] <- t(x-t(colMeans(x)%*%t(matrix(rep(1, n), nrow=n))))%*%(x-t(colMeans(x)%*%t(matrix(rep(1, n), nrow=n))))/n + diag(abs(rnorm(2)))*5 # t(scale(x, center=TRUE, scale=FALSE))%*%scale(x, center=TRUE, scale=FALSE)
mu[,k] <- mu_tmp[, k] # colMeans(x) + rnorm(2)*5
}
# EM Algorithm
e_step <- function(Pi, mu, Sig){
zz <- rep(0, n*K); dim(zz) <- c(n, K)
for (ii in 1:n) {
for (k in 1:K) {
zz[ii, k] <- Pi[k]*dmvnorm(x[ii,], mean=mu[,k], sigma=Sig[,,k])
}
tmp <- sum(zz[ii,])
for (k in 1:K) {
zz[ii, k] <- zz[ii, k] / tmp
}
}
return(zz)
}
m_step <- function(zz){
Pi <- colMeans(zz)
for (k in 1:K) {
mu[,k] <- colSums(matrix(unlist(lapply(1:n, function(ii) zz[ii,k] * x[ii,])), nrow=n, byrow=TRUE)) / colSums(zz)[k]
Sig[,,k] <- matrix(colSums(matrix(unlist(lapply(1:n, function(ii) zz[ii,k] * t(t(x[ii,]-mu[,k]))%*%t(x[ii,]-mu[,k]) )), nrow=n, byrow=TRUE)), nrow=Dim) / colSums(zz)[k]
}
return(list(Pi, mu, Sig))
}
iter_num <- 0
while (TRUE) {
z <- e_step(Pi, mu, Sig)
re <- m_step(z)
Pi_new <- re[[1]]; mu_new <- re[[2]]; Sig_new <- re[[3]]
if (norm(matrix(Pi_new-Pi))<eps & norm(mu-mu_new)<eps & norm(Sig[,,1]-Sig_new[,,1])<eps & norm(Sig[,,2]-Sig_new[,,2])<eps) break
Pi <- Pi_new; mu <- mu_new; Sig <- Sig_new
iter_num <- iter_num + 1
}
cat("number of iterations = ", iter_num, "\n")
print(Pi)
print(mu)
print(Sig)
library("mixtools")
result.EM = mvnormalmixEM(x, k=2)
print(result.EM$lambda)
print(result.EM$mu)
print(result.EM$sigma)
library("FNN")
library("parallel")
k <- 10
# kdist <- knn.dist(x, k=k)
f.knn <- function(t){
h <- knnx.dist(data=x, query=t, k=k)[1,10]
idx_t <- knnx.index(data=x, query=t, k=k)
fhx <- 0
for (ii in 1:dim(idx_t)[2]) {
if (norm(x[idx_t[ii],] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.05)
zz <- seq(40, 100, 0.1)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'k', 'knnx.dist', 'knnx.index'))                # include all the function needed
res <- parSapply(cl, 1:length(yy), ex)
stopCluster(cl)
# draw density  fucntion
library("plotly")
plot_ly() %>%
add_surface(z = ~res)
persp(yy, zz, res, phi=45, theta=45)
library("FNN")
library("parallel")
k <- 10
# kdist <- knn.dist(x, k=k)
f.knn <- function(t){
h <- knnx.dist(data=x, query=t, k=k)[1,10]
idx_t <- knnx.index(data=x, query=t, k=k)
fhx <- 0
for (ii in 1:dim(idx_t)[2]) {
if (norm(x[idx_t[ii],] - t, "2") / h < 1)
fhx <- fhx + 1 / h
}
fhx / (2*length(x))
}
yy <- seq(1, 5.5, 0.01)
zz <- seq(40, 100, 0.5)
f.hat <- matrix(rep(0, length(yy)*length(zz)), nrow=length(yy))
ex <- function(ii){
unlist(lapply(1:length(zz), function(jj, y) {
tt <- matrix(c(y, zz[jj]), nrow=1)
return(f.knn(tt))
}, yy[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('f.knn', 'x', 'yy', 'zz', 'k', 'knnx.dist', 'knnx.index'))                # include all the function needed
res <- parSapply(cl, 1:length(yy), ex)
stopCluster(cl)
# draw density  fucntion
library("plotly")
plot_ly() %>%
add_surface(z = ~res)
aa=matrix(res)
View(aa)
aa=matrix(res, nrow=121, byrow=TRUE)
persp(yy,zz,aa)
persp(x=yy,y=zz,z=aa)
