xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=30)
y <- seq(40, 100, length.out=30)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
# bandwith selection
Sig <- cov(dat)
H.plug_in <- diag(diag(Sig)) * n^(-1/6) * (4 / 6)^(1/6)
H.scott <- diag(diag(Sig)) * n^(-1/6)
H.g_scott <- n^(-1/6) * Sig^(1/2)
estimate <- function(H){
# # single core code
# for(ii in 1:length(x)){
#   for (jj in 1:length(y)) {
#     u <- c(x[ii], y[jj])
#     f.hat.multiple[ii, jj] <- kde.multiple(u, H)
#     f.hat.sphi[ii, jj] <- kde.sphi(u, H)
#   }
# }
# more cores code
ex.multiple <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
ex.sphi <- function(ii){
# ii: different index of x
# jj: index of y
unlist(lapply(1:length(y), function(jj, xx) {
u <- c(xx, y[jj])
return(kde.multiple(u, H))
}, x[ii]))
}
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H.plug_in', 'H.scott', 'H.g_scott', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
f.hat.multiple <- parSapply(cl, 1:length(x), ex.multiple)
stopCluster(cl)
cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
clusterExport(cl, c('dat' ,'x' , 'y', 'H.plug_in', 'H.scott', 'H.g_scott', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
f.hat.sphi <- parSapply(cl, 1:length(x), ex.sphi)
stopCluster(cl)
plot_ly() %>% add_surface(z = ~f.hat.multiple)
plot_ly() %>% add_surface(z = ~f.hat.sphi)
}
estimate(H.plug_in)
estimate(H.scott)
estimate(H.g_scott)
data("faithful")
dat <- data.matrix(faithful)
n <- dim(dat)[1]
Dim <- 2
multip.kernel <- function(u){
# u is a vector in 2-dim
(1-u[1])*(1-u[2])*9/16
}
sphi.kernel <- function(u){
# u is a vector in 2-dim
(1-t(u)%*%u)*2/pi
}
kde.multiple <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (abs(xx[1]) <=1 & abs(xx[2]) <=1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
kde.sphi <- function(u, H){
fhx <- 0
for (ii in 1:n) {
xx <- solve(H) %*% (u - dat[ii, ])
if (norm(xx, "2") <= 1)
fhx <- fhx + 1
}
fhx <- fhx / n / det(H)
}
x <- seq(1, 5.5, length.out=30)
y <- seq(40, 100, length.out=30)
f.hat.multiple <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
f.hat.sphi <- matrix(rep(0, length(x)*length(y)), nrow=length(x))
# bandwith selection
Sig <- cov(dat)
H.plug_in <- diag(diag(Sig)) * n^(-1/6) * (4 / 6)^(1/6)
H.scott <- diag(diag(Sig)) * n^(-1/6)
H.g_scott <- n^(-1/6) * Sig^(1/2)
estimate <- function(H){
# single core code
for(ii in 1:length(x)){
for (jj in 1:length(y)) {
u <- c(x[ii], y[jj])
f.hat.multiple[ii, jj] <- kde.multiple(u, H)
f.hat.sphi[ii, jj] <- kde.sphi(u, H)
}
}
# # more cores code
# ex.multiple <- function(ii){
#   # ii: different index of x
#   # jj: index of y
#   unlist(lapply(1:length(y), function(jj, xx) {
#                                       u <- c(xx, y[jj])
#                                       return(kde.multiple(u, H))
#                             }, x[ii]))
# }
# ex.sphi <- function(ii){
#   # ii: different index of x
#   # jj: index of y
#   unlist(lapply(1:length(y), function(jj, xx) {
#                                       u <- c(xx, y[jj])
#                                       return(kde.multiple(u, H))
#                             }, x[ii]))
# }
# cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
# clusterExport(cl, c('dat' ,'x' , 'y', 'H.plug_in', 'H.scott', 'H.g_scott', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
# f.hat.multiple <- parSapply(cl, 1:length(x), ex.multiple)
# stopCluster(cl)
#
# cl <- makeCluster(getOption("cl.cores", as.integer(detectCores()/2)))
# clusterExport(cl, c('dat' ,'x' , 'y', 'H.plug_in', 'H.scott', 'H.g_scott', 'n', 'kde.sphi', 'kde.multiple', 'sphi.kernel', 'sphi.kernel'))                # include all the function needed
# f.hat.sphi <- parSapply(cl, 1:length(x), ex.sphi)
# stopCluster(cl)
plot_ly() %>% add_surface(z = ~f.hat.multiple)
plot_ly() %>% add_surface(z = ~f.hat.sphi)
}
estimate(H.plug_in)
estimate(H.scott)
estimate(H.g_scott)
H.g_scott
H.scott
H.plug_in
n^(-1/6)
H.g_scott
H.scott
H.plug_in
Sig
Sig^(1/2)
knitr::opts_chunk$set(echo = TRUE)
data('faithful')
dat <- data.matrix(faithful)
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat[1])
ker <- function(t, x, h){
# t is the estimated point
# x is data
# h is bandwidth
fhx <- 0
for (xx in x) {
fhx <- fhx + dnorm((t-xx)/h)
}
fhx / (h * length(x))
}
f.hat.remove_i <- function(i){
idx <- 1:n; idx <- idx[-i]
lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y}) / (n-1)
}
tmp1 <- lapply(1:n, FUN=f.hat.remove_i)
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat[1])
ker <- function(t, x, h){
# t is the estimated point
# x is data
# h is bandwidth
fhx <- 0
for (xx in x) {
fhx <- fhx + dnorm((t-xx)/h)
}
fhx / (h * length(x))
}
f.hat.remove_i <- function(i){
idx <- 1:n; idx <- idx[-i]
lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y}) / (n-1)
}
tmp1 <- lapply(X=1:n, FUN=f.hat.remove_i)
tmp1 <- lapply(X=1:n, FUN=f.hat.remove_i)
i=1
idx <- 1:n; idx <- idx[-i]
idx <- 1:n
c(1:n)
idx <- seq(1,n);
n <- dim(dat[1])
n <- dim(dat)[1]
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
ker <- function(t, x, h){
# t is the estimated point
# x is data
# h is bandwidth
fhx <- 0
for (xx in x) {
fhx <- fhx + dnorm((t-xx)/h)
}
fhx / (h * length(x))
}
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y}) / (n-1)
}
tmp1 <- lapply(X=1:n, FUN=f.hat.remove_i)
h.x <- n^(-1/5)
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- n^(-1/5)
ker <- function(t, x, h){
# t is the estimated point
# x is data
# h is bandwidth
fhx <- 0
for (xx in x) {
fhx <- fhx + dnorm((t-xx)/h)
}
fhx / (h * length(x))
}
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y}) / (n-1)
}
tmp1 <- lapply(X=1:n, FUN=f.hat.remove_i)
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
ker <- function(t, x, h){
# t is the estimated point
# x is data
# h is bandwidth
fhx <- 0
for (xx in x) {
fhx <- fhx + dnorm((t-xx)/h)
}
fhx / (h * length(x))
}
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y}) / (n-1)
}
tmp1 <- lapply(X=1:n, FUN=f.hat.remove_i)
idx <- seq(1,n); idx <- idx[-i]
lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
ker <- function(t, x, h){
# t is the estimated point
# x is data
# h is bandwidth
fhx <- 0
for (xx in x) {
fhx <- fhx + dnorm((t-xx)/h)
}
fhx / (h * length(x))
}
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})) / (n-1)
}
tmp1 <- lapply(X=1:n, FUN=f.hat.remove_i)
View(tmp1)
a = unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y}))
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
ker <- function(t, x, h){
# t is the estimated point
# x is data
# h is bandwidth
fhx <- 0
for (xx in x) {
fhx <- fhx + dnorm((t-xx)/h)
}
fhx / (h * length(x))
}
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
tmp1 <- lapply(X=1:n, FUN=f.hat.remove_i)
View(tmp1)
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
ker <- function(t, x, h){
# t is the estimated point
# x is data
# h is bandwidth
fhx <- 0
for (xx in x) {
fhx <- fhx + dnorm((t-xx)/h)
}
fhx / (h * length(x))
}
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
tmp1 <- unlist(lapply(X=1:n, FUN=f.hat.remove_i))
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
f1.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x })))
}
f2.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
tmp1 <- unlist(lapply(X=1:n, FUN=f.hat.remove_i)) / n
tmp2 <- unlist(lapply(X=1:n, FUN=f1.hat.remove_i)) * unlist(lapply(X=1:n, FUN=f1.hat.remove_i)) / n^2
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
f1.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x })))
}
f2.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
f12.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x }))) * mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
tmp1 <- unlist(lapply(X=1:n, FUN=f.hat.remove_i)) / n
tmp2 <- unlist(lapply(X=1:n, FUN=f1.hat.remove_i)) * unlist(lapply(X=1:n, FUN=f1.hat.remove_i)) / n^2
tmp3 <- unlist(lapply(X=1:n, FUN=f12.hat.remove_i)) * 2 / n
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
f1.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x })))
}
f2.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
f12.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x }))) * mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
tmp1 <- unlist(lapply(X=1:n, FUN=f.hat.remove_i)) / n
tmp2 <- unlist(lapply(X=1:n, FUN=f1.hat.remove_i)) * unlist(lapply(X=1:n, FUN=f1.hat.remove_i)) / n^2
tmp3 <- unlist(lapply(X=1:n, FUN=f12.hat.remove_i)) * 2 / n
I <- tmp1 + tmp2 - tmp3
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
f1.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x })))
}
f2.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
f12.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x }))) * mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
tmp1 <- mean(unlist(lapply(X=1:n, FUN=f.hat.remove_i)))
tmp2 <- mean(unlist(lapply(X=1:n, FUN=f1.hat.remove_i))) * mean(unlist(lapply(X=1:n, FUN=f1.hat.remove_i)))
tmp3 <- mean(unlist(lapply(X=1:n, FUN=f12.hat.remove_i))) * 2
I <- tmp1 + tmp2 - tmp3
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
f1.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x })))
}
f2.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
f12.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x }))) * mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
tmp1 <- mean(unlist(lapply(X=1:n, FUN=f.hat.remove_i)))
tmp2 <- mean(unlist(lapply(X=1:n, FUN=f1.hat.remove_i))) * mean(unlist(lapply(X=1:n, FUN=f1.hat.remove_i)))
tmp3 <- mean(unlist(lapply(X=1:n, FUN=f12.hat.remove_i))) * 2
I <- tmp1 + tmp2 - tmp3
cat('We get I.hat = ', I,'\n')
ii
ii=1
(1:n)[-ii]
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
f1.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x })))
}
f2.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
f12.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x }))) * mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
tmp1 <- mean(unlist(lapply(X=1:n, FUN=f.hat.remove_i)))
tmp2 <- mean(unlist(lapply(X=1:n, FUN=f1.hat.remove_i))) * mean(unlist(lapply(X=1:n, FUN=f1.hat.remove_i)))
tmp3 <- mean(unlist(lapply(X=1:n, FUN=f12.hat.remove_i))) * 2
I <- tmp1 + tmp2 - tmp3
cat('We get I.hat = ', I,'\n')
tmp <- 0
for (ii in 1:n) {
for (jj in (1:n)[-ii]) {
tmp <- tmp + (dnorm((dat[ii,1]-dat[jj,1])/h.x))^2 * (dnorm((dat[ii,2]-dat[jj,2])/h.y))^2
}
}
sigma.sq <- 2 / n^2 / h.x / h.y * tmp
T <- n * sqrt(h.x*h.y) * I / sigma.sq
cat('We get T = ', T,'\n')
sigma.sq
2 / n^2 / h.x / h.y
tmp
data('faithful')
dat <- data.matrix(faithful)
n <- dim(dat)[1]
h.x <- h.y <- n^(-1/5)
f.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) * dnorm((dat[jj,2]-dat[i,2])/h.y) / h.x / h.y})))
}
f1.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x })))
}
f2.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
f12.hat.remove_i <- function(i){
idx <- seq(1,n); idx <- idx[-i]
mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,1]-dat[i,1])/h.x) / h.x }))) * mean(unlist(lapply(X=idx, FUN=function(jj){dnorm((dat[jj,2]-dat[i,2])/h.y) / h.y})))
}
tmp1 <- mean(unlist(lapply(X=1:n, FUN=f.hat.remove_i)))
tmp2 <- mean(unlist(lapply(X=1:n, FUN=f1.hat.remove_i))) * mean(unlist(lapply(X=1:n, FUN=f1.hat.remove_i)))
tmp3 <- mean(unlist(lapply(X=1:n, FUN=f12.hat.remove_i))) * 2
I <- tmp1 + tmp2 - tmp3
cat('We get I.hat = ', I,'\n')
tmp <- 0
for (ii in 1:n) {
for (jj in (1:n)[-ii]) {
tmp <- tmp + (dnorm((dat[ii,1]-dat[jj,1])/h.x))^2 * (dnorm((dat[ii,2]-dat[jj,2])/h.y))^2
}
}
sigma.sq <- 2 * tmp / n^2 / h.x / h.y
T <- n * sqrt(h.x*h.y) * I / sqrt(sigma.sq)
cat('Statistic T = ', T,'\n')
cov(dat)
cov(scale(dat))
chisq.test(dat[,1], dat[,2])
fisher.test(dat[,1], dat[,2])
fisher.test(dat[,1], dat[,2], simulate.p.value=TRUE)
